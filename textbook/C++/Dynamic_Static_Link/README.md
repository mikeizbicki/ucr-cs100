
#Topic: The differences between dynamic and static linking library

##Table content:
1. Terminology:
	* simple clear definition of all the computer science terminology that will be mentioned in this document. 

2. Introduction dynamic link and static link:
	* definition of dynamic link 
	* definition of static link
	* advantage of dynamic link
	* disadvantage of dynamic link
	* examples of dynamic link in real application
	* advantage of static link
	* disadvantage of static link
	* examples of static link in real application

3. Application of dynamic link and static link:
	* how to use dynamic link
	* how to use static link
	* when to use dynamic link and when to use static link

4. summary

5. Reference

##Terminology in Computer Science:

1. ***object code(object module)***: object code is that a computer compiler produces: In general, object code is a sequence of statements or instructions in a computer language. such as machine code language or an intermediate language like RHL.

2. ***object file***: is a file containing object code, meaning relocatable format machine code that is usually not directly executable

3. ***object files***: may contain metadata used for linking or debugging, including: information to resolve symbolic cross-references between different modules, relocation information, stack unwinding information, comments, program symbols, debugging or profiling information.

4. ***Executable file*** is a computer file that contains instructions in a form that a computer's operating system or application can understand and follow.  Computers must use executable files to carry out the tasks that you give to them.  Every application you run starts off with an executable program.

5. C++ is a compiled language so you need to translate the source code in a file that the computer can execute. This file is generated by the compiler and is called the object code ( .obj ), but a program like the "hello world" program is composed by a part that we wrote and a part of the C++ library. The linker links these two parts of a program and produces an executable file ( .exe ).

6. ***Object code*** is a portion of machine code that hasn't yet been linked into a complete program. It's the machine code for one particular library or module that will make up the completed product. It may also contain placeholders or offsets not found in the machine code of a completed program that the linker will use to connect everything together.

7. ***linker*** or ***link editor*** is a computer program that takes one or more object files generated by a computer compiler and combines them into a single executable file, library file, or another object file.

8. ***Link editors are commonly known as linkers***. The compiler automatically invokes the linker as the last step in compiling a program. The linker inserts code (or maps in shared libraries) to resolve program library references, and/or combines object modules into an executable image suitable for loading into memory. On Unix-like systems, the linker is typically invoked with the ld command.

9. ***Static linking*** is the result of the linker copying all library routines used in the program into the executable image. This may require more disk space and memory than dynamic linking, but is both faster and more portable, since it does not require the presence of the library on the system where it is run.

10. ***Dynamic linking*** is accomplished by placing the name of a sharable library in the executable image. Actual linking with the library routines does not occur until the image is run, when both the executable and the library are placed in memory. An advantage of dynamic linking is that multiple programs can share a single copy of the library.

11. ***Shared libraries*** are .so (or in Windows .dll, or in OS X .dylib) files. All the code relating to the library is in this file, and it is referenced by programs using it at run-time. A program using a shared library only makes reference to the code that it uses in the shared library.

12. ***Static libraries*** are .a (or in Windows .lib) files. All the code relating to the library is in this file, and it is directly linked into the program at compile time. A program using a static library takes copies of the code that it uses from the static library and makes it part of the program. (Windows also has .lib files which are used to reference .dll files, but they act the same way as the first one).

13. ***Advantage: Shared libraries***: 
	1. reduce the amount of code that is duplicated in each program that makes use of the library,
	2. keep the binaries small. 
	3. replace the shared object with one that is functionally equivalent, but may have added performance benefits without needing to recompile the program that makes use of it. 
	4. can be loaded into an application at run-time, which is the general mechanism for implementing binary plug-in systems.

14. ***Disadvantage: Shared libraries***: 
	1. a small additional cost for the execution of the functions and 
	2. a run-time loading cost because all the symbols in the library need to be connected to the things they use.

15. ***Advantage: Static libraries***: 
	1. don't need to carry along a copy of the library that is being used. 
	2. as the code is connected at compile time there are not any additional run-time loading costs. The code is simply there.

16. ***Disadvantage: Static libraries***: 
	1. increase the overall size of the binary file , 

##Reference:
1. [Static, Shared Dynamic and Loadable Linux Libraries](http://www.yolinux.com/TUTORIALS/LibraryArchives-StaticAndDynamic.html)

2. [Difference between static and shared libraries](http://stackoverflow.com/questions/2649334/difference-between-static-and-shared-libraries)

3. [Systems Programming: What is the exact difference between Dynamic loading and dynamic linking?](http://www.quora.com/Systems-Programming/What-is-the-exact-difference-between-Dynamic-loading-and-dynamic-linking)

